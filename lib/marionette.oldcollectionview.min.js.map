{"version":3,"sources":["src/common/trigger-method.js","src/common/view.js","src/common/monitor-view-events.js","src/error.js","src/utils/emulate-collection.js","src/child-view-container.js","src/collection-view.js","src/composite-view.js","src/old.js"],"names":["getEventName","match","prefix","eventName","toUpperCase","triggerMethod","event","args","Array","_len","_key","arguments","methodName","getOnMethodName","method","getOption","this","result","_","isFunction","apply","trigger","triggerMethodOn","context","_len2","_key2","renderView","view","_isRendered","supportsRenderLifecycle","render","destroyView","destroy","supportsDestroyLifecycle","shouldTriggerDetach","_isAttached","_shouldDisableEvents","remove","_isDestroyed","triggerMethodChildren","shouldTrigger","_getImmediateChildren","each","child","shouldTriggerAttach","shouldAttach","shouldDetach","triggerDOMRefresh","triggerDOMRemove","handleBeforeAttach","handleAttach","handleBeforeDetach","handleDetach","handleBeforeRender","handleRender","monitorViewEvents","_areViewEventsMonitored","on","extend","View","errorProps","MarionetteError","call","Error","message","options","isObject","error","pick","captureStackTrace","url","urlRoot","name","splitter","memoize","replace","Marionette","methods","Container","views","_views","_indexByModel","_indexByCustom","_updateLength","bind","add","object","listProperty","list","prototype","slice","concat","emulateCollection","values","customIndex","_add","viewCid","cid","model","findByModelCid","modelCid","findByCid","index","_remove","some","key","length","size","isNodeAttached","el","document","documentElement","contains","parentNode","setDomApi","ViewMixin","ClassOptions","CollectionView","Backbone","_setOptions","mergeOptions","_initBehaviors","once","_initialEvents","_initChildViewStorage","_bufferedChildren","constructor","delegateEntityEvents","_triggerEventOnBehaviors","_isBuffering","triggerOnChildren","attachBuffer","_createBuffer","children","collection","listenTo","_onCollectionAdd","_onCollectionUpdate","sort","_sortViews","opts","undefined","at","indexOf","filter","_filteredSortedModels","_shouldAddChild","_destroyEmptyView","_addChild","changes","_removeChildModels","removed","models","removedViews","_getRemovedViews","_updateIndices","isEmpty","_showEmptyView","reduce","removingViews","_this","findByModel","_removeChildView","push","stopListening","hasEl","setElement","_renderChildren","preventRender","canBeRendered","filterChanged","previousModels","_applyModelDeltas","setFilter","currentIds","_this2","removeModels","prevModel","_showingEmptyView","filteredOutModels","elsToReorder","viewEls","_index","elBuffer","Dom","createBuffer","appendContents","_appendReorderedChildren","reorderOnSort","reorder","find","item","_this4","resortView","_$el","$el","_destroyChildren","processedModels","_startBuffering","_showCollection","_endBuffering","ChildView","_getChildView","childViewOptions","_getChildViewOptions","buildChildView","_proxyChildViewEvents","addedAt","viewComparator","getViewComparator","Math","min","max","addedModel","_sortModelsBy","splice","_filterModels","_this5","comparator","sortBy","get","clone","EmptyView","_getEmptyView","Model","emptyViewOptions","_emptyViewIndex","addChildView","emptyView","_getView","childView","_createView","_setupChildView","_attachView","increment","isArray","laterView","attachHtml","ChildViewClass","collectionView","buffer","b","_$contents","_insertBefore","_insertAfter","currentView","beforeEl","siblings","$","before","ChildViewContainer","CompositeView","renderChildren","serializeModel","_isRendering","resetChildViewContainer","template","getTemplate","_renderTemplate","bindUIElements","compositeView","$container","getChildViewContainer","containerView","$childViewContainer","container","childViewContainer","selector","charAt","ui","substr","MixinFromView","OldCollectionView","OldCompositeView"],"mappings":"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","file":"marionette.oldcollectionview.min.js","sourcesContent":["// Trigger Method\n// --------------\n\nimport _ from 'underscore';\nimport Marionette, { getOption } from 'backbone.marionette';\n\n// split the event name on the \":\"\nconst splitter = /(^|:)(\\w)/gi;\n\n// take the event section (\"section1:section2:section3\")\n// and turn it in to uppercase name onSection1Section2Section3\nfunction getEventName(match, prefix, eventName) {\n  return eventName.toUpperCase();\n}\n\nconst getOnMethodName = _.memoize(function(event) {\n  return 'on' + event.replace(splitter, getEventName);\n});\n\n// Trigger an event and/or a corresponding method name. Examples:\n//\n// `this.triggerMethod(\"foo\")` will trigger the \"foo\" event and\n// call the \"onFoo\" method.\n//\n// `this.triggerMethod(\"foo:bar\")` will trigger the \"foo:bar\" event and\n// call the \"onFooBar\" method.\nexport function triggerMethod(event, ...args) {\n  // get the method name from the event name\n  const methodName = getOnMethodName(event);\n  const method = getOption(this, methodName);\n  let result;\n\n  // call the onMethodName if it exists\n  if (_.isFunction(method)) {\n    // pass all args, except the event name\n    result = method.apply(this, args);\n  }\n\n  // trigger the event\n  this.trigger.apply(this, arguments);\n\n  return result;\n}\n\n// triggerMethodOn invokes triggerMethod on a specific context\n//\n// e.g. `Marionette.triggerMethodOn(view, 'show')`\n// will trigger a \"show\" event or invoke onShow the view.\nfunction triggerMethodOn(context, ...args) {\n  if (_.isFunction(context.triggerMethod)) {\n    return context.triggerMethod.apply(context, args);\n  }\n\n  return triggerMethod.apply(context, args);\n}\n\n// For tests\nMarionette.triggerMethodOn = triggerMethodOn;\n\nexport {\n  triggerMethodOn\n}\n","import { triggerMethodOn } from '../common/trigger-method';\n\nexport function renderView(view) {\n  if (view._isRendered) {\n    return;\n  }\n\n  if (!view.supportsRenderLifecycle) {\n    triggerMethodOn(view, 'before:render', view);\n  }\n\n  view.render();\n\n  if (!view.supportsRenderLifecycle) {\n    view._isRendered = true;\n    triggerMethodOn(view, 'render', view);\n  }\n}\n\nexport function destroyView(view) {\n  if (view.destroy) {\n    view.destroy();\n    return;\n  }\n\n  if (!view.supportsDestroyLifecycle) {\n    triggerMethodOn(view, 'before:destroy', view);\n  }\n\n  const shouldTriggerDetach = view._isAttached && !view._shouldDisableEvents;\n\n  if (shouldTriggerDetach) {\n    triggerMethodOn(view, 'before:detach', view);\n  }\n\n  view.remove();\n\n  if (shouldTriggerDetach) {\n    view._isAttached = false;\n    triggerMethodOn(view, 'detach', view);\n  }\n\n  view._isDestroyed = true;\n\n  if (!view.supportsDestroyLifecycle) {\n    triggerMethodOn(view, 'destroy', view);\n  }\n}\n","// DOM Refresh\n// -----------\n\nimport _ from 'underscore';\nimport { triggerMethodOn } from './trigger-method';\n\n// Trigger method on children unless a pure Backbone.View\nfunction triggerMethodChildren(view, event, shouldTrigger) {\n  if (!view._getImmediateChildren) { return; }\n  _.each(view._getImmediateChildren(), child => {\n    if (!shouldTrigger(child)) { return; }\n    triggerMethodOn(child, event, child);\n  });\n}\n\nfunction shouldTriggerAttach(view) {\n  return !view._isAttached;\n}\n\nfunction shouldAttach(view) {\n  if (!shouldTriggerAttach(view)) { return false; }\n  view._isAttached = true;\n  return true;\n}\n\nfunction shouldTriggerDetach(view) {\n  return view._isAttached;\n}\n\nfunction shouldDetach(view) {\n  if (!shouldTriggerDetach(view)) { return false; }\n  view._isAttached = false;\n  return true;\n}\n\nfunction triggerDOMRefresh(view) {\n  if (view._isAttached && view._isRendered) {\n    triggerMethodOn(view, 'dom:refresh', view);\n  }\n}\n\nfunction triggerDOMRemove(view) {\n  if (view._isAttached && view._isRendered) {\n    triggerMethodOn(view, 'dom:remove', view);\n  }\n}\n\nfunction handleBeforeAttach() {\n  triggerMethodChildren(this, 'before:attach', shouldTriggerAttach);\n}\n\nfunction handleAttach() {\n  triggerMethodChildren(this, 'attach', shouldAttach);\n  triggerDOMRefresh(this);\n}\n\nfunction handleBeforeDetach() {\n  triggerMethodChildren(this, 'before:detach', shouldTriggerDetach);\n  triggerDOMRemove(this);\n}\n\nfunction handleDetach() {\n  triggerMethodChildren(this, 'detach', shouldDetach);\n}\n\nfunction handleBeforeRender() {\n  triggerDOMRemove(this);\n}\n\nfunction handleRender() {\n  triggerDOMRefresh(this);\n}\n\n// Monitor a view's state, propagating attach/detach events to children and firing dom:refresh\n// whenever a rendered view is attached or an attached view is rendered.\nfunction monitorViewEvents(view) {\n  if (view._areViewEventsMonitored || view.monitorViewEvents === false) { return; }\n\n  view._areViewEventsMonitored = true;\n\n  view.on({\n    'before:attach': handleBeforeAttach,\n    'attach': handleAttach,\n    'before:detach': handleBeforeDetach,\n    'detach': handleDetach,\n    'before:render': handleBeforeRender,\n    'render': handleRender\n  });\n}\n\nexport default monitorViewEvents;\n","// Error\n// -----\n\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nconst extend = View.extend;\n\nconst errorProps = ['description', 'fileName', 'lineNumber', 'name', 'message', 'number'];\n\nconst MarionetteError = extend.call(Error, {\n  urlRoot: 'https://github.com/marionettejs/marionette.oldcollectionview/tree/master/',\n\n  constructor(message, options) {\n    if (_.isObject(message)) {\n      options = message;\n      message = options.message;\n    } else if (!options) {\n      options = {};\n    }\n\n    const error = Error.call(this, message);\n    _.extend(this, _.pick(error, errorProps), _.pick(options, errorProps));\n\n    this.captureStackTrace();\n\n    if (options.url) {\n      this.url = this.urlRoot + options.url;\n    }\n  },\n\n  captureStackTrace() {\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, MarionetteError);\n    }\n  },\n\n  toString() {\n    return this.name + ': ' + this.message + (this.url ? ' See: ' + this.url : '');\n  }\n});\n\nMarionetteError.extend = extend;\n\nexport default MarionetteError;\n","// Mix in methods from Underscore, for iteration, and other\n// collection related features.\n// Borrowing this code from Backbone.Collection:\n// https://github.com/jashkenas/backbone/blob/1.1.2/backbone.js#L962\n\nimport _ from 'underscore';\n\nconst methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',\n                'select', 'reject', 'every', 'all', 'some', 'any', 'include',\n                'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',\n                'last', 'without', 'isEmpty', 'pluck', 'reduce', 'partition'];\n\nconst emulateCollection = function(object, listProperty) {\n  _.each(methods, function(method) {\n    object[method] = function() {\n      const list = _.result(this, listProperty);\n      const args = Array.prototype.slice.call(arguments);\n      return _[method].apply(_, [list].concat(args));\n    };\n  });\n};\n\nexport default emulateCollection;\n","import _ from 'underscore';\nimport emulateCollection from './utils/emulate-collection';\n\n// Provide a container to store, retrieve and\n// shut down child views.\nconst Container = function(views) {\n  this._views = {};\n  this._indexByModel = {};\n  this._indexByCustom = {};\n  this._updateLength();\n\n  _.each(views, _.bind(this.add, this));\n};\n\nemulateCollection(Container.prototype, '_getViews');\n\n// Container Methods\n// -----------------\n\n_.extend(Container.prototype, {\n\n  _getViews() {\n    return _.values(this._views);\n  },\n\n  // Add a view to this container. Stores the view\n  // by `cid` and makes it searchable by the model\n  // cid (and model itself). Optionally specify\n  // a custom key to store an retrieve the view.\n  add(view, customIndex) {\n    return this._add(view, customIndex)._updateLength();\n  },\n\n  // To be used when avoiding call _updateLength\n  // When you are done adding all your new views\n  // call _updateLength\n  _add(view, customIndex) {\n    const viewCid = view.cid;\n\n    // store the view\n    this._views[viewCid] = view;\n\n    // index it by model\n    if (view.model) {\n      this._indexByModel[view.model.cid] = viewCid;\n    }\n\n    // index by custom\n    if (customIndex) {\n      this._indexByCustom[customIndex] = viewCid;\n    }\n\n    return this;\n  },\n\n  // Find a view by the model that was attached to\n  // it. Uses the model's `cid` to find it.\n  findByModel(model) {\n    return this.findByModelCid(model.cid);\n  },\n\n  // Find a view by the `cid` of the model that was attached to\n  // it. Uses the model's `cid` to find the view `cid` and\n  // retrieve the view using it.\n  findByModelCid(modelCid) {\n    const viewCid = this._indexByModel[modelCid];\n    return this.findByCid(viewCid);\n  },\n\n  // Find a view by a custom indexer.\n  findByCustom(index) {\n    const viewCid = this._indexByCustom[index];\n    return this.findByCid(viewCid);\n  },\n\n  // Find by index. This is not guaranteed to be a\n  // stable index.\n  findByIndex(index) {\n    return _.values(this._views)[index];\n  },\n\n  // retrieve a view by its `cid` directly\n  findByCid(cid) {\n    return this._views[cid];\n  },\n\n  // Remove a view\n  remove(view) {\n    return this._remove(view)._updateLength();\n  },\n\n  // To be used when avoiding call _updateLength\n  // When you are done adding all your new views\n  // call _updateLength\n  _remove(view) {\n    const viewCid = view.cid;\n\n    // delete model index\n    if (view.model) {\n      delete this._indexByModel[view.model.cid];\n    }\n\n    // delete custom index\n    _.some(this._indexByCustom, _.bind(function(cid, key) {\n      if (cid === viewCid) {\n        delete this._indexByCustom[key];\n        return true;\n      }\n    }, this));\n\n    // remove the view from the container\n    delete this._views[viewCid];\n\n    return this;\n  },\n\n  // Update the `.length` attribute on this container\n  _updateLength() {\n    this.length = _.size(this._views);\n\n    return this;\n  }\n});\n\nexport default Container;\n","// Collection View\n// ---------------\n\nimport _ from 'underscore';\nimport Backbone from 'backbone';\nimport { View } from 'backbone.marionette';\nimport MarionetteError from './error';\n\nimport { renderView, destroyView } from './common/view';\nimport monitorViewEvents from './common/monitor-view-events';\nimport { triggerMethodOn } from './common/trigger-method';\nimport ChildViewContainer from './child-view-container';\n\nconst isNodeAttached = function(el) {\n  return document.documentElement.contains(el && el.parentNode);\n};\n\nconst setDomApi = View.setDomApi;\n\nconst ViewMixin = _.pick(View.prototype,\n  'Dom',\n  'supportsRenderLifecycle',\n  'supportsDestroyLifecycle',\n  '_isDestroyed',\n  'isDestroyed',\n  '_isRendered',\n  'isRendered',\n  '_isAttached',\n  'isAttached',\n  'delegateEvents',\n  '_getEvents',\n  '_getTriggers',\n  'delegateEntityEvents',\n  'undelegateEntityEvents',\n  'destroy',\n  '_removeElement',\n  'bindUIElements',\n  'unbindUIElements',\n  'getUI',\n  'triggerMethod',\n  '_buildEventProxies',\n  '_getEventPrefix',\n  '_proxyChildViewEvents',\n  '_childViewEventHandler',\n  // BehaviorsMixin\n  '_initBehaviors',\n  '_getBehaviors',\n  '_getBehaviorTriggers',\n  '_getBehaviorEvents',\n  '_proxyBehaviorViewProperties',\n  '_delegateBehaviorEntityEvents',\n  '_undelegateBehaviorEntityEvents',\n  '_deleteEntityEventHandlers',\n  '_destroyBehaviors',\n  '_removeBehavior',\n  '_bindBehaviorUIElements',\n  '_unbindBehaviorUIElements',\n  '_triggerEventOnBehaviors',\n  // CommonMixin\n  'normalizeMethods',\n  '_setOptions',\n  'mergeOptions',\n  'getOption',\n  'bindEvents',\n  'unbindEvents',\n  // DelegateEntityEventsMixin\n  '_delegateEntityEvents',\n  '_undelegateEntityEvents',\n  // TriggersMixin\n  '_getViewTriggers',\n  // UIMixin\n  'normalizeUIKeys',\n  'normalizeUIString',\n  'normalizeUIValues',\n  '_getUIBindings',\n  '_bindUIElements',\n  '_unbindUIElements',\n  '_getUI'\n);\n\nconst ClassOptions = [\n  'behaviors',\n  'childView',\n  'childViewEventPrefix',\n  'childViewEvents',\n  'childViewOptions',\n  'childViewTriggers',\n  'collectionEvents',\n  'events',\n  'filter',\n  'emptyView',\n  'emptyViewOptions',\n  'modelEvents',\n  'reorderOnSort',\n  'sort',\n  'triggers',\n  'ui',\n  'viewComparator'\n];\n\n// A view that iterates over a Backbone.Collection\n// and renders an individual child view for each model.\nconst CollectionView = Backbone.View.extend({\n\n  childViewEventPrefix: 'childview',\n\n  // flag for maintaining the sorted order of the collection\n  sort: true,\n\n  // constructor\n  // option to pass `{sort: false}` to prevent the `CollectionView` from\n  // maintaining the sorted order of the collection.\n  // This will fallback onto appending childView's to the end.\n  //\n  // option to pass `{viewComparator: compFunction()}` to allow the `CollectionView`\n  // to use a custom sort order for the collection.\n  constructor(options) {\n    this.render = _.bind(this.render, this);\n\n    this._setOptions(options);\n\n    this.mergeOptions(options, ClassOptions);\n\n    monitorViewEvents(this);\n\n    this._initBehaviors();\n    this.once('render', this._initialEvents);\n    this._initChildViewStorage();\n    this._bufferedChildren = [];\n\n    const args = Array.prototype.slice.call(arguments);\n    args[0] = this.options;\n    Backbone.View.prototype.constructor.apply(this, args);\n\n    this.delegateEntityEvents();\n\n    this._triggerEventOnBehaviors('initialize', this);\n  },\n\n  // Instead of inserting elements one by one into the page, it's much more performant to insert\n  // elements into a document fragment and then insert that document fragment into the page\n  _startBuffering() {\n    this._isBuffering = true;\n  },\n\n  _endBuffering() {\n    const shouldTriggerAttach = this._isAttached && this.monitorViewEvents !== false;\n    const triggerOnChildren = shouldTriggerAttach ? this._getImmediateChildren() : [];\n\n    this._isBuffering = false;\n\n    _.each(triggerOnChildren, child => {\n      triggerMethodOn(child, 'before:attach', child);\n    });\n\n    this.attachBuffer(this, this._createBuffer());\n\n    _.each(triggerOnChildren, child => {\n      child._isAttached = true;\n      triggerMethodOn(child, 'attach', child);\n    });\n\n    this._bufferedChildren = [];\n  },\n\n  _getImmediateChildren() {\n    return _.values(this.children._views);\n  },\n\n  // Configured the initial events that the collection view binds to.\n  _initialEvents() {\n    if (this.collection) {\n      this.listenTo(this.collection, 'add', this._onCollectionAdd);\n      this.listenTo(this.collection, 'update', this._onCollectionUpdate);\n      this.listenTo(this.collection, 'reset', this.render);\n\n      if (this.sort) {\n        this.listenTo(this.collection, 'sort', this._sortViews);\n      }\n    }\n  },\n\n  // Handle a child added to the collection\n  _onCollectionAdd(child, collection, opts) {\n    // `index` is present when adding with `at` since BB 1.2; indexOf fallback for < 1.2\n    let index = opts.at !== undefined && (opts.index || collection.indexOf(child));\n\n    // When filtered or when there is no initial index, calculate index.\n    if (this.filter || index === false) {\n      index = _.indexOf(this._filteredSortedModels(index), child);\n    }\n\n    if (this._shouldAddChild(child, index)) {\n      this._destroyEmptyView();\n      this._addChild(child, index)\n    }\n  },\n\n  // Handle collection update model removals\n  _onCollectionUpdate(collection, options) {\n    const changes = options.changes;\n    this._removeChildModels(changes.removed);\n  },\n\n  // Remove the child views and destroy them.\n  // This function also updates the indices of later views\n  // in the collection in order to keep the children in sync with the collection.\n  // \"models\" is an array of models and the corresponding views\n  // will be removed and destroyed from the CollectionView\n  _removeChildModels(models) {\n    // Used to determine where to update the remaining\n    // sibling view indices after these views are removed.\n    const removedViews = this._getRemovedViews(models);\n\n    if (!removedViews.length) {\n      return;\n    }\n\n    this.children._updateLength();\n\n    // decrement the index of views after this one\n    this._updateIndices(removedViews, false);\n\n    if (this.isEmpty()) {\n      this._showEmptyView();\n    }\n  },\n\n  // Returns the views that will be used for re-indexing\n  // through CollectionView#_updateIndices.\n  _getRemovedViews(models) {\n\n    // Returning a view means something was removed.\n    return _.reduce(models, (removingViews, model) => {\n      const view = model && this.children.findByModel(model);\n\n      if (!view || view._isDestroyed) {\n        return removingViews;\n      }\n\n      this._removeChildView(view);\n\n      removingViews.push(view);\n\n      return removingViews;\n    }, []);\n  },\n\n  _removeChildView(view) {\n    this.triggerMethod('before:remove:child', this, view);\n\n    this.children._remove(view);\n    view._shouldDisableEvents = this.monitorViewEvents === false;\n    destroyView(view);\n\n    this.stopListening(view);\n    this.triggerMethod('remove:child', this, view);\n  },\n\n  // Overriding Backbone.View's `setElement` to handle\n  // if an el was previously defined. If so, the view might be\n  // attached on setElement.\n  setElement() {\n    const hasEl = !!this.el;\n\n    Backbone.View.prototype.setElement.apply(this, arguments);\n\n    if (hasEl) {\n      this._isAttached = isNodeAttached(this.el);\n    }\n\n    return this;\n  },\n\n  // Render children views. Override this method to provide your own implementation of a\n  // render function for the collection view.\n  render() {\n    if (this._isDestroyed) { return this; }\n    this.triggerMethod('before:render', this);\n    this._renderChildren();\n    this._isRendered = true;\n    this.triggerMethod('render', this);\n    return this;\n  },\n\n  // An efficient rendering used for filtering. Instead of modifying the whole DOM for the\n  // collection view, we are only adding or removing the related childrenViews.\n  setFilter(filter, {preventRender} = {}) {\n    const canBeRendered = this._isRendered && !this._isDestroyed;\n    const filterChanged = this.filter !== filter;\n    const shouldRender = canBeRendered && filterChanged && !preventRender;\n\n    if (shouldRender) {\n      const previousModels = this._filteredSortedModels();\n      this.filter = filter;\n      const models = this._filteredSortedModels();\n      this._applyModelDeltas(models, previousModels);\n    } else {\n      this.filter = filter;\n    }\n\n    return this;\n  },\n\n  // `removeFilter` is actually an alias for removing filters.\n  removeFilter(options) {\n    return this.setFilter(null, options);\n  },\n\n  // Calculate and apply difference by cid between `models` and `previousModels`.\n  _applyModelDeltas(models, previousModels) {\n    const currentIds = {};\n    _.each(models, (model, index) => {\n      const addedChildNotExists = !this.children.findByModel(model);\n      if (addedChildNotExists) {\n        this._onCollectionAdd(model, this.collection, {at: index});\n      }\n      currentIds[model.cid] = true;\n    });\n\n    const removeModels = _.filter(previousModels, (prevModel) => {\n      return !currentIds[prevModel.cid] && this.children.findByModel(prevModel);\n    });\n\n    this._removeChildModels(removeModels);\n  },\n\n  // Reorder DOM after sorting. When your element's rendering do not use their index,\n  // you can pass reorderOnSort: true to only reorder the DOM after a sort instead of\n  // rendering all the collectionView.\n  reorder() {\n    const children = this.children;\n    const models = this._filteredSortedModels();\n\n    if (!models.length && this._showingEmptyView) { return this; }\n\n    const anyModelsAdded = _.some(models, function(model) {\n      return !children.findByModel(model);\n    });\n\n    // If there are any new models added due to filtering we need to add child views,\n    // so render as normal.\n    if (anyModelsAdded) {\n      this.render();\n    } else {\n\n      const filteredOutModels = [];\n\n      // Get the DOM nodes in the same order as the models and\n      // find the model that were children before but aren't in this new order.\n      const elsToReorder = _.reduce(this.children._views, function(viewEls, view) {\n        const index = _.indexOf(models, view.model);\n\n        if (index === -1) {\n          filteredOutModels.push(view.model);\n          return viewEls;\n        }\n\n        view._index = index;\n\n        viewEls[index] = view.el;\n\n        return viewEls;\n      }, new Array(models.length));\n\n      this.triggerMethod('before:reorder', this);\n\n      const elBuffer = this.Dom.createBuffer();\n\n      _.each(elsToReorder, (el) => {\n        this.Dom.appendContents(elBuffer, el);\n      });\n\n      // Since append moves elements that are already in the DOM, appending the elements\n      // will effectively reorder them.\n      this._appendReorderedChildren(elBuffer);\n\n      // remove any views that have been filtered out\n      this._removeChildModels(filteredOutModels);\n\n      this.triggerMethod('reorder', this);\n    }\n    return this;\n  },\n\n  // Render view after sorting. Override this method to change how the view renders\n  // after a `sort` on the collection.\n  resortView() {\n    if (this.reorderOnSort) {\n      this.reorder();\n    } else {\n      this._renderChildren();\n    }\n    return this;\n  },\n\n  // Internal method. This checks for any changes in the order of the collection.\n  // If the index of any view doesn't match, it will render.\n  _sortViews() {\n    const models = this._filteredSortedModels();\n\n    // check for any changes in sort order of views\n    const orderChanged = _.find(models, (item, index) => {\n      const view = this.children.findByModel(item);\n      return !view || view._index !== index;\n    });\n\n    if (orderChanged) {\n      this.resortView();\n    }\n  },\n\n  // Internal reference to what index a `emptyView` is.\n  _emptyViewIndex: -1,\n\n  // Internal method. Separated so that CompositeView can append to the childViewContainer\n  // if necessary\n  _appendReorderedChildren(children) {\n    this.Dom.appendContents(this.el, children, {_$el: this.$el});\n  },\n\n  // Internal method. Separated so that CompositeView can have more control over events\n  // being triggered, around the rendering process\n  _renderChildren() {\n    if (this._isRendered) {\n      this._destroyEmptyView();\n      this._destroyChildren();\n    }\n\n    const models = this._filteredSortedModels();\n    if (this.isEmpty({processedModels: models})) {\n      this._showEmptyView();\n    } else {\n      this.triggerMethod('before:render:children', this);\n      this._startBuffering();\n      this._showCollection(models);\n      this._endBuffering();\n      this.triggerMethod('render:children', this);\n    }\n  },\n\n  _createView(model, index) {\n    const ChildView = this._getChildView(model);\n    const childViewOptions = this._getChildViewOptions(model, index);\n    const view = this.buildChildView(model, ChildView, childViewOptions);\n    return view;\n  },\n\n  _setupChildView(view, index) {\n    monitorViewEvents(view);\n\n    // set up the child view event forwarding\n    this._proxyChildViewEvents(view);\n\n    if (this.sort) {\n      view._index = index;\n    }\n  },\n\n  // Internal method to loop through collection and show each child view.\n  _showCollection(models) {\n    _.each(models, _.bind(this._addChild, this));\n    this.children._updateLength();\n  },\n\n  // Allow the collection to be sorted by a custom view comparator\n  _filteredSortedModels(addedAt) {\n    if (!this.collection || !this.collection.length) { return []; }\n\n    const viewComparator = this.getViewComparator();\n    let models = this.collection.models;\n    addedAt = Math.min(Math.max(addedAt, 0), models.length - 1);\n\n    if (viewComparator) {\n      let addedModel;\n      // Preserve `at` location, even for a sorted view\n      if (addedAt) {\n        addedModel = models[addedAt];\n        models = models.slice(0, addedAt).concat(models.slice(addedAt + 1));\n      }\n      models = this._sortModelsBy(models, viewComparator);\n      if (addedModel) {\n        models.splice(addedAt, 0, addedModel);\n      }\n    }\n\n    // Filter after sorting in case the filter uses the index\n    models = this._filterModels(models);\n\n    return models;\n  },\n\n  getViewComparator() {\n    return this.viewComparator;\n  },\n\n  // Filter an array of models, if a filter exists\n  _filterModels(models) {\n    if (this.filter) {\n      models = _.filter(models, (model, index) => {\n        return this._shouldAddChild(model, index);\n      });\n    }\n    return models;\n  },\n\n  _sortModelsBy(models, comparator) {\n    if (typeof comparator === 'string') {\n      return _.sortBy(models, (model) => {\n        return model.get(comparator);\n      });\n    } else if (comparator.length === 1) {\n      return _.sortBy(models, _.bind(comparator, this));\n    } else {\n      return _.clone(models).sort(_.bind(comparator, this));\n    }\n  },\n\n  // Internal method to show an empty view in place of a collection of child views,\n  // when the collection is empty\n  _showEmptyView() {\n    const EmptyView = this._getEmptyView();\n\n    if (EmptyView && !this._showingEmptyView) {\n      this._showingEmptyView = true;\n\n      const model = new Backbone.Model();\n      let emptyViewOptions =\n        this.emptyViewOptions || this.childViewOptions;\n      if (_.isFunction(emptyViewOptions)) {\n        emptyViewOptions = emptyViewOptions.call(this, model, this._emptyViewIndex);\n      }\n\n      const view = this.buildChildView(model, EmptyView, emptyViewOptions);\n\n      this.triggerMethod('before:render:empty', this, view);\n      this.addChildView(view, 0);\n      this.triggerMethod('render:empty', this, view);\n    }\n  },\n\n  // Internal method to destroy an existing emptyView instance if one exists. Called when\n  // a collection view has been rendered empty, and then a child is added to the collection.\n  _destroyEmptyView() {\n    if (this._showingEmptyView) {\n      this.triggerMethod('before:remove:empty', this);\n\n      this._destroyChildren();\n      delete this._showingEmptyView;\n\n      this.triggerMethod('remove:empty', this);\n    }\n  },\n\n  // Retrieve the empty view class\n  _getEmptyView() {\n    const emptyView = this.emptyView;\n\n    if (!emptyView) { return; }\n\n    return this._getView(emptyView);\n  },\n\n  // Retrieve the `childView` class\n  // The `childView` property can be either a view class or a function that\n  // returns a view class. If it is a function, it will receive the model that\n  // will be passed to the view instance (created from the returned view class)\n  _getChildView(child) {\n    let childView = this.childView;\n\n    if (!childView) {\n      throw new MarionetteError({\n        name: 'NoChildViewError',\n        message: 'A \"childView\" must be specified'\n      });\n    }\n\n    childView = this._getView(childView, child);\n\n    if (!childView) {\n      throw new MarionetteError({\n        name: 'InvalidChildViewError',\n        message: '\"childView\" must be a view class or a function that returns a view class'\n      });\n    }\n\n    return childView;\n  },\n\n  // First check if the `view` is a view class (the common case)\n  // Then check if it's a function (which we assume that returns a view class)\n  _getView(view, child) {\n    if (view.prototype instanceof Backbone.View || view === Backbone.View) {\n      return view;\n    } else if (_.isFunction(view)) {\n      return view.call(this, child);\n    }\n  },\n\n  // Internal method for building and adding a child view\n  _addChild(child, index) {\n    const view = this._createView(child, index);\n    this.addChildView(view, index);\n\n    return view;\n  },\n\n  _getChildViewOptions(child, index) {\n    if (_.isFunction(this.childViewOptions)) {\n      return this.childViewOptions(child, index);\n    }\n\n    return this.childViewOptions;\n  },\n\n  // Render the child's view and add it to the HTML for the collection view at a given index.\n  // This will also update the indices of later views in the collection in order to keep the\n  // children in sync with the collection.\n  addChildView(view, index) {\n    this.triggerMethod('before:add:child', this, view);\n    this._setupChildView(view, index);\n\n    // Store the child view itself so we can properly remove and/or destroy it later\n    if (this._isBuffering) {\n      // Add to children, but don't update children's length.\n      this.children._add(view);\n    } else {\n      // increment indices of views after this one\n      this._updateIndices(view, true);\n      this.children.add(view);\n    }\n\n    renderView(view);\n\n    this._attachView(view, index);\n\n    this.triggerMethod('add:child', this, view);\n\n    return view;\n  },\n\n  // Internal method. This decrements or increments the indices of views after the added/removed\n  // view to keep in sync with the collection.\n  _updateIndices(views, increment) {\n    if (!this.sort) {\n      return;\n    }\n\n    if (!increment) {\n      _.each(_.sortBy(this.children._views, '_index'), (view, index) => {\n        view._index = index;\n      });\n\n      return;\n    }\n\n    const view = _.isArray(views) ? _.max(views, '_index') : views;\n\n    if (_.isObject(view)) {\n      // update the indexes of views after this one\n      _.each(this.children._views, (laterView) => {\n        if (laterView._index >= view._index) {\n          laterView._index += 1;\n        }\n      });\n    }\n  },\n\n  _attachView(view, index) {\n    // Only trigger attach if already attached and not buffering,\n    // otherwise _endBuffering() or Region#show() handles this.\n    const shouldTriggerAttach = !view._isAttached && !this._isBuffering && this._isAttached && this.monitorViewEvents !== false;\n\n    if (shouldTriggerAttach) {\n      triggerMethodOn(view, 'before:attach', view);\n    }\n\n    this.attachHtml(this, view, index);\n\n    if (shouldTriggerAttach) {\n      view._isAttached = true;\n      triggerMethodOn(view, 'attach', view);\n    }\n  },\n\n  // Build a `childView` for a model in the collection.\n  buildChildView(child, ChildViewClass, childViewOptions) {\n    const options = _.extend({model: child}, childViewOptions);\n    return new ChildViewClass(options);\n  },\n\n  // Remove the child view and destroy it. This function also updates the indices of later views\n  // in the collection in order to keep the children in sync with the collection.\n  removeChildView(view) {\n    if (!view || view._isDestroyed) {\n      return view;\n    }\n\n    this._removeChildView(view);\n    this.children._updateLength();\n    // decrement the index of views after this one\n    this._updateIndices(view, false);\n    return view;\n  },\n\n  // check if the collection is empty or optionally whether an array of pre-processed models is empty\n  isEmpty(options) {\n    let models;\n    if (_.result(options, 'processedModels')) {\n      models = options.processedModels;\n    } else {\n      models = this.collection ? this.collection.models : [];\n      models = this._filterModels(models);\n    }\n    return models.length === 0;\n  },\n\n  // You might need to override this if you've overridden attachHtml\n  attachBuffer(collectionView, buffer) {\n    this.Dom.appendContents(collectionView.el, buffer, {_$el: collectionView.$el});\n  },\n\n  // Create a fragment buffer from the currently buffered children\n  _createBuffer() {\n    const elBuffer = this.Dom.createBuffer();\n    _.each(this._bufferedChildren, (b) => {\n      this.Dom.appendContents(elBuffer, b.el, {_$contents: b.$el});\n    });\n    return elBuffer;\n  },\n\n  // Append the HTML to the collection's `el`. Override this method to do something other\n  // than `.append`.\n  attachHtml(collectionView, childView, index) {\n    if (collectionView._isBuffering) {\n      // buffering happens on reset events and initial renders\n      // in order to reduce the number of inserts into the\n      // document, which are expensive.\n      collectionView._bufferedChildren.splice(index, 0, childView);\n    } else {\n      // If we've already rendered the main collection, append\n      // the new child into the correct order if we need to. Otherwise\n      // append to the end.\n      if (!collectionView._insertBefore(childView, index)) {\n        collectionView._insertAfter(childView);\n      }\n    }\n  },\n\n  // Internal method. Check whether we need to insert the view into the correct position.\n  _insertBefore(childView, index) {\n    let currentView;\n    const findPosition = this.sort && (index < this.children.length - 1);\n    if (findPosition) {\n      // Find the view after this one\n      currentView = _.find(this.children._views, (view) => {\n        return view._index === index + 1;\n      });\n    }\n\n    if (currentView) {\n      this.beforeEl(currentView.el, childView.el);\n      return true;\n    }\n\n    return false;\n  },\n\n  // Override to handle DOM inserting differently\n  beforeEl(el, siblings) {\n    this.$(el).before(siblings);\n  },\n\n  // Internal method. Append a view to the end of the $el\n  _insertAfter(childView) {\n    this.Dom.appendContents(this.el, childView.el, {_$el: this.$el, _$contents: childView.$el});\n  },\n\n  // Internal method to set up the `children` object for storing all of the child views\n  _initChildViewStorage() {\n    this.children = new ChildViewContainer();\n  },\n\n  // called by ViewMixin destroy\n  _removeChildren() {\n    this._destroyChildren();\n  },\n\n  // Destroy the child views that this collection view is holding on to, if any\n  _destroyChildren(options) {\n    if (!this.children.length) {\n      return;\n    }\n\n    this.triggerMethod('before:destroy:children', this);\n    _.each(this.children._views, _.bind(this._removeChildView, this));\n    this.children._updateLength();\n    this.triggerMethod('destroy:children', this);\n  },\n\n  // Return true if the given child should be shown. Return false otherwise.\n  // The filter will be passed (child, index, collection), where\n  //  'child' is the given model\n  //  'index' is the index of that model in the collection\n  //  'collection' is the collection referenced by this CollectionView\n  _shouldAddChild(child, index) {\n    const filter = this.filter;\n    return !_.isFunction(filter) || filter.call(this, child, index, this.collection);\n  }\n}, {\n  setDomApi\n});\n\n_.extend(CollectionView.prototype, ViewMixin);\n\nexport default CollectionView;\n","// Composite View\n// --------------\n\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\nimport CollectionView from './collection-view';\nimport MarionetteError from './error';\n\nconst ClassOptions = [\n  'childViewContainer',\n  'template',\n  'templateContext'\n];\n\n// Used for rendering a branch-leaf, hierarchical structure.\n// Extends directly from CollectionView\n// @deprecated\nconst CompositeView = CollectionView.extend({\n\n  // Setting up the inheritance chain which allows changes to\n  // Marionette.CollectionView.prototype.constructor which allows overriding\n  // option to pass '{sort: false}' to prevent the CompositeView from\n  // maintaining the sorted order of the collection.\n  // This will fallback onto appending childView's to the end.\n  constructor(options) {\n    this.mergeOptions(options, ClassOptions);\n\n    CollectionView.prototype.constructor.apply(this, arguments);\n  },\n\n  // Configured the initial events that the composite view\n  // binds to. Override this method to prevent the initial\n  // events, or to add your own initial events.\n  _initialEvents() {\n\n    // Bind only after composite view is rendered to avoid adding child views\n    // to nonexistent childViewContainer\n\n    if (this.collection) {\n      this.listenTo(this.collection, 'add', this._onCollectionAdd);\n      this.listenTo(this.collection, 'update', this._onCollectionUpdate);\n      this.listenTo(this.collection, 'reset', this.renderChildren);\n\n      if (this.sort) {\n        this.listenTo(this.collection, 'sort', this._sortViews);\n      }\n    }\n  },\n\n  // Retrieve the `childView` to be used when rendering each of\n  // the items in the collection. The default is to return\n  // `this.childView` or Marionette.CompositeView if no `childView`\n  // has been defined. As happens in CollectionView, `childView` can\n  // be a function (which should return a view class).\n  _getChildView(child) {\n    let childView = this.childView;\n\n    // for CompositeView, if `childView` is not specified, we'll get the same\n    // composite view class rendered for each child in the collection\n    // then check if the `childView` is a view class (the common case)\n    // finally check if it's a function (which we assume that returns a view class)\n    if (!childView) {\n      return this.constructor;\n    }\n\n    childView = this._getView(childView, child);\n\n    if (!childView) {\n      throw new MarionetteError({\n        name: 'InvalidChildViewError',\n        message: '\"childView\" must be a view class or a function that returns a view class'\n      });\n    }\n\n    return childView;\n  },\n\n  // Return the serialized model\n  serializeData() {\n    if (this.model) { return this.serializeModel(); }\n  },\n\n  // Renders the model and the collection.\n  render() {\n    if (this._isDestroyed) { return this; }\n    this._isRendering = true;\n    this.resetChildViewContainer();\n\n    this.triggerMethod('before:render', this);\n\n    const template = this.getTemplate();\n    if (template !== false) { this._renderTemplate(template); }\n    this.bindUIElements();\n    this.renderChildren();\n\n    this._isRendering = false;\n    this._isRendered = true;\n    this.triggerMethod('render', this);\n    return this;\n  },\n\n  renderChildren() {\n    if (this._isRendered || this._isRendering) {\n      CollectionView.prototype._renderChildren.call(this);\n    }\n  },\n\n  // You might need to override this if you've overridden attachHtml\n  attachBuffer(compositeView, buffer) {\n    const $container = this.getChildViewContainer(compositeView);\n    this.Dom.appendContents($container[0], buffer, {_$el: $container});\n  },\n\n  // Internal method. Append a view to the end of the $el.\n  // Overidden from CollectionView to ensure view is appended to\n  // childViewContainer\n  _insertAfter(childView) {\n    const $container = this.getChildViewContainer(this, childView);\n    this.Dom.appendContents($container[0], childView.el, {_$el: $container, _$contents: childView.$el});\n  },\n\n  // Internal method. Append reordered childView'.\n  // Overidden from CollectionView to ensure reordered views\n  // are appended to childViewContainer\n  _appendReorderedChildren(children) {\n    const $container = this.getChildViewContainer(this);\n    this.Dom.appendContents($container[0], children, {_$el: $container});\n  },\n\n  // Internal method to ensure an `$childViewContainer` exists, for the\n  // `attachHtml` method to use.\n  getChildViewContainer(containerView, childView) {\n    if (!!containerView.$childViewContainer) {\n      return containerView.$childViewContainer;\n    }\n\n    let container;\n    const childViewContainer = containerView.childViewContainer;\n    if (childViewContainer) {\n\n      const selector = _.result(containerView, 'childViewContainer');\n\n      if (selector.charAt(0) === '@' && containerView.ui) {\n        container = containerView.ui[selector.substr(4)];\n      } else {\n        container = this.$(selector);\n      }\n\n      if (container.length <= 0) {\n        throw new MarionetteError({\n          name: 'ChildViewContainerMissingError',\n          message: `The specified \"childViewContainer\" was not found: ${containerView.childViewContainer}`\n        });\n      }\n\n    } else {\n      container = containerView.$el;\n    }\n\n    containerView.$childViewContainer = container;\n    return container;\n  },\n\n  // Internal method to reset the `$childViewContainer` on render\n  resetChildViewContainer() {\n    if (this.$childViewContainer) {\n      this.$childViewContainer = undefined;\n    }\n  }\n});\n\n// To prevent duplication but allow the best View organization\n// Certain View methods are mixed directly into the deprecated CompositeView\nconst MixinFromView = _.pick(View.prototype, 'serializeModel', 'getTemplate', '_renderTemplate', '_renderHtml', 'mixinTemplateContext', 'attachElContent');\n_.extend(CompositeView.prototype, MixinFromView);\n\nexport default CompositeView;\n","import Marionette from 'backbone.marionette';\nimport OldCollectionView from './collection-view';\nimport OldCompositeView from './composite-view';\n\n// Support the default export\nMarionette.OldCollectionView = OldCollectionView;\nMarionette.OldCompositeView = OldCompositeView;\n\nexport { OldCollectionView, OldCompositeView }\n"]}