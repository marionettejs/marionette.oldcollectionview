{"version":3,"sources":["src/common/trigger-method.js","src/common/view.js","src/common/monitor-view-events.js","src/utils/emulate-collection.js","src/child-view-container.js","src/collection-view.js","src/composite-view.js","src/old.js"],"names":["getEventName","match","prefix","eventName","toUpperCase","triggerMethod","event","args","Array","_len","_key","arguments","methodName","getOnMethodName","method","Marionette","getOption","this","result","_","isFunction","apply","trigger","triggerMethodOn","context","_len2","_key2","renderView","view","_isRendered","supportsRenderLifecycle","render","destroyView","destroy","supportsDestroyLifecycle","shouldTriggerDetach","_isAttached","_shouldDisableEvents","remove","_isDestroyed","triggerMethodChildren","shouldTrigger","_getImmediateChildren","each","child","shouldTriggerAttach","shouldAttach","shouldDetach","triggerDOMRefresh","triggerDOMRemove","handleBeforeAttach","handleAttach","handleBeforeDetach","handleDetach","handleBeforeRender","handleRender","monitorViewEvents","_areViewEventsMonitored","on","splitter","memoize","replace","methods","Container","views","_views","_indexByModel","_indexByCustom","_updateLength","bind","add","object","listProperty","list","prototype","slice","call","concat","emulateCollection","extend","values","customIndex","_add","viewCid","cid","model","findByModelCid","modelCid","findByCid","index","_remove","some","key","length","size","setDomApi","View","ViewMixin","pick","isNodeAttached","MarionetteError","Error","ClassOptions","CollectionView","Backbone","options","_setOptions","mergeOptions","_initBehaviors","once","_initialEvents","_initChildViewStorage","_bufferedChildren","constructor","delegateEntityEvents","_triggerEventOnBehaviors","_isBuffering","triggerOnChildren","attachBuffer","_createBuffer","children","collection","listenTo","_onCollectionAdd","_onCollectionUpdate","sort","_sortViews","opts","undefined","at","indexOf","filter","_filteredSortedModels","_shouldAddChild","_destroyEmptyView","_addChild","changes","_removeChildModels","removed","models","removedViews","_getRemovedViews","_updateIndices","isEmpty","_showEmptyView","reduce","removingViews","_this","findByModel","_removeChildView","push","stopListening","hasEl","el","setElement","_renderChildren","preventRender","canBeRendered","filterChanged","previousModels","_applyModelDeltas","setFilter","currentIds","_this2","removeModels","prevModel","_showingEmptyView","filteredOutModels","elsToReorder","viewEls","_index","elBuffer","Dom","createBuffer","appendContents","_appendReorderedChildren","reorderOnSort","reorder","find","item","_this4","resortView","_$el","$el","_destroyChildren","processedModels","_startBuffering","_showCollection","_endBuffering","ChildView","_getChildView","childViewOptions","_getChildViewOptions","buildChildView","_proxyChildViewEvents","addedAt","viewComparator","getViewComparator","Math","min","max","addedModel","_sortModelsBy","splice","_filterModels","_this5","comparator","sortBy","get","clone","EmptyView","_getEmptyView","Model","emptyViewOptions","_emptyViewIndex","addChildView","emptyView","_getView","childView","_createView","_setupChildView","_attachView","increment","isArray","isObject","laterView","attachHtml","ChildViewClass","collectionView","buffer","b","_$contents","_insertBefore","_insertAfter","currentView","beforeEl","siblings","$","before","ChildViewContainer","CompositeView","renderChildren","serializeModel","_isRendering","resetChildViewContainer","_renderTemplate","bindUIElements","compositeView","$container","getChildViewContainer","containerView","$childViewContainer","container","childViewContainer","selector","charAt","ui","substr","MixinFromView","OldCollectionView","OldCompositeView"],"mappings":"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","file":"marionette.oldcollectionview.min.js","sourcesContent":["// Trigger Method\n// --------------\n\nimport _ from 'underscore';\nimport Marionette from 'backbone.marionette';\n\n// split the event name on the \":\"\nconst splitter = /(^|:)(\\w)/gi;\n\n// take the event section (\"section1:section2:section3\")\n// and turn it in to uppercase name onSection1Section2Section3\nfunction getEventName(match, prefix, eventName) {\n  return eventName.toUpperCase();\n}\n\nconst getOnMethodName = _.memoize(function(event) {\n  return 'on' + event.replace(splitter, getEventName);\n});\n\n// Trigger an event and/or a corresponding method name. Examples:\n//\n// `this.triggerMethod(\"foo\")` will trigger the \"foo\" event and\n// call the \"onFoo\" method.\n//\n// `this.triggerMethod(\"foo:bar\")` will trigger the \"foo:bar\" event and\n// call the \"onFooBar\" method.\nexport function triggerMethod(event, ...args) {\n  // get the method name from the event name\n  const methodName = getOnMethodName(event);\n  const method = Marionette.getOption(this, methodName);\n  let result;\n\n  // call the onMethodName if it exists\n  if (_.isFunction(method)) {\n    // pass all args, except the event name\n    result = method.apply(this, args);\n  }\n\n  // trigger the event\n  this.trigger.apply(this, arguments);\n\n  return result;\n}\n\n// triggerMethodOn invokes triggerMethod on a specific context\n//\n// e.g. `Marionette.triggerMethodOn(view, 'show')`\n// will trigger a \"show\" event or invoke onShow the view.\nexport function triggerMethodOn(context, ...args) {\n  if (_.isFunction(context.triggerMethod)) {\n    return context.triggerMethod.apply(context, args);\n  }\n\n  return triggerMethod.apply(context, args);\n}\n","import { triggerMethodOn } from '../common/trigger-method';\n\nexport function renderView(view) {\n  if (view._isRendered) {\n    return;\n  }\n\n  if (!view.supportsRenderLifecycle) {\n    triggerMethodOn(view, 'before:render', view);\n  }\n\n  view.render();\n\n  if (!view.supportsRenderLifecycle) {\n    view._isRendered = true;\n    triggerMethodOn(view, 'render', view);\n  }\n}\n\nexport function destroyView(view) {\n  if (view.destroy) {\n    view.destroy();\n    return;\n  }\n\n  if (!view.supportsDestroyLifecycle) {\n    triggerMethodOn(view, 'before:destroy', view);\n  }\n\n  const shouldTriggerDetach = view._isAttached && !view._shouldDisableEvents;\n\n  if (shouldTriggerDetach) {\n    triggerMethodOn(view, 'before:detach', view);\n  }\n\n  view.remove();\n\n  if (shouldTriggerDetach) {\n    view._isAttached = false;\n    triggerMethodOn(view, 'detach', view);\n  }\n\n  view._isDestroyed = true;\n\n  if (!view.supportsDestroyLifecycle) {\n    triggerMethodOn(view, 'destroy', view);\n  }\n}\n","// DOM Refresh\n// -----------\n\nimport _ from 'underscore';\nimport { triggerMethodOn } from './trigger-method';\n\n// Trigger method on children unless a pure Backbone.View\nfunction triggerMethodChildren(view, event, shouldTrigger) {\n  if (!view._getImmediateChildren) { return; }\n  _.each(view._getImmediateChildren(), child => {\n    if (!shouldTrigger(child)) { return; }\n    triggerMethodOn(child, event, child);\n  });\n}\n\nfunction shouldTriggerAttach(view) {\n  return !view._isAttached;\n}\n\nfunction shouldAttach(view) {\n  if (!shouldTriggerAttach(view)) { return false; }\n  view._isAttached = true;\n  return true;\n}\n\nfunction shouldTriggerDetach(view) {\n  return view._isAttached;\n}\n\nfunction shouldDetach(view) {\n  if (!shouldTriggerDetach(view)) { return false; }\n  view._isAttached = false;\n  return true;\n}\n\nfunction triggerDOMRefresh(view) {\n  if (view._isAttached && view._isRendered) {\n    triggerMethodOn(view, 'dom:refresh', view);\n  }\n}\n\nfunction triggerDOMRemove(view) {\n  if (view._isAttached && view._isRendered) {\n    triggerMethodOn(view, 'dom:remove', view);\n  }\n}\n\nfunction handleBeforeAttach() {\n  triggerMethodChildren(this, 'before:attach', shouldTriggerAttach);\n}\n\nfunction handleAttach() {\n  triggerMethodChildren(this, 'attach', shouldAttach);\n  triggerDOMRefresh(this);\n}\n\nfunction handleBeforeDetach() {\n  triggerMethodChildren(this, 'before:detach', shouldTriggerDetach);\n  triggerDOMRemove(this);\n}\n\nfunction handleDetach() {\n  triggerMethodChildren(this, 'detach', shouldDetach);\n}\n\nfunction handleBeforeRender() {\n  triggerDOMRemove(this);\n}\n\nfunction handleRender() {\n  triggerDOMRefresh(this);\n}\n\n// Monitor a view's state, propagating attach/detach events to children and firing dom:refresh\n// whenever a rendered view is attached or an attached view is rendered.\nfunction monitorViewEvents(view) {\n  if (view._areViewEventsMonitored || view.monitorViewEvents === false) { return; }\n\n  view._areViewEventsMonitored = true;\n\n  view.on({\n    'before:attach': handleBeforeAttach,\n    'attach': handleAttach,\n    'before:detach': handleBeforeDetach,\n    'detach': handleDetach,\n    'before:render': handleBeforeRender,\n    'render': handleRender\n  });\n}\n\nexport default monitorViewEvents;\n","// Mix in methods from Underscore, for iteration, and other\n// collection related features.\n// Borrowing this code from Backbone.Collection:\n// https://github.com/jashkenas/backbone/blob/1.1.2/backbone.js#L962\n\nimport _ from 'underscore';\n\nconst methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',\n                'select', 'reject', 'every', 'all', 'some', 'any', 'include',\n                'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',\n                'last', 'without', 'isEmpty', 'pluck', 'reduce', 'partition'];\n\nconst emulateCollection = function(object, listProperty) {\n  _.each(methods, function(method) {\n    object[method] = function() {\n      const list = _.result(this, listProperty);\n      const args = Array.prototype.slice.call(arguments);\n      return _[method].apply(_, [list].concat(args));\n    };\n  });\n};\n\nexport default emulateCollection;\n","import _ from 'underscore';\nimport emulateCollection from './utils/emulate-collection';\n\n// Provide a container to store, retrieve and\n// shut down child views.\nconst Container = function(views) {\n  this._views = {};\n  this._indexByModel = {};\n  this._indexByCustom = {};\n  this._updateLength();\n\n  _.each(views, _.bind(this.add, this));\n};\n\nemulateCollection(Container.prototype, '_getViews');\n\n// Container Methods\n// -----------------\n\n_.extend(Container.prototype, {\n\n  _getViews() {\n    return _.values(this._views);\n  },\n\n  // Add a view to this container. Stores the view\n  // by `cid` and makes it searchable by the model\n  // cid (and model itself). Optionally specify\n  // a custom key to store an retrieve the view.\n  add(view, customIndex) {\n    return this._add(view, customIndex)._updateLength();\n  },\n\n  // To be used when avoiding call _updateLength\n  // When you are done adding all your new views\n  // call _updateLength\n  _add(view, customIndex) {\n    const viewCid = view.cid;\n\n    // store the view\n    this._views[viewCid] = view;\n\n    // index it by model\n    if (view.model) {\n      this._indexByModel[view.model.cid] = viewCid;\n    }\n\n    // index by custom\n    if (customIndex) {\n      this._indexByCustom[customIndex] = viewCid;\n    }\n\n    return this;\n  },\n\n  // Find a view by the model that was attached to\n  // it. Uses the model's `cid` to find it.\n  findByModel(model) {\n    return this.findByModelCid(model.cid);\n  },\n\n  // Find a view by the `cid` of the model that was attached to\n  // it. Uses the model's `cid` to find the view `cid` and\n  // retrieve the view using it.\n  findByModelCid(modelCid) {\n    const viewCid = this._indexByModel[modelCid];\n    return this.findByCid(viewCid);\n  },\n\n  // Find a view by a custom indexer.\n  findByCustom(index) {\n    const viewCid = this._indexByCustom[index];\n    return this.findByCid(viewCid);\n  },\n\n  // Find by index. This is not guaranteed to be a\n  // stable index.\n  findByIndex(index) {\n    return _.values(this._views)[index];\n  },\n\n  // retrieve a view by its `cid` directly\n  findByCid(cid) {\n    return this._views[cid];\n  },\n\n  // Remove a view\n  remove(view) {\n    return this._remove(view)._updateLength();\n  },\n\n  // To be used when avoiding call _updateLength\n  // When you are done adding all your new views\n  // call _updateLength\n  _remove(view) {\n    const viewCid = view.cid;\n\n    // delete model index\n    if (view.model) {\n      delete this._indexByModel[view.model.cid];\n    }\n\n    // delete custom index\n    _.some(this._indexByCustom, _.bind(function(cid, key) {\n      if (cid === viewCid) {\n        delete this._indexByCustom[key];\n        return true;\n      }\n    }, this));\n\n    // remove the view from the container\n    delete this._views[viewCid];\n\n    return this;\n  },\n\n  // Update the `.length` attribute on this container\n  _updateLength() {\n    this.length = _.size(this._views);\n\n    return this;\n  }\n});\n\nexport default Container;\n","// Collection View\n// ---------------\n\nimport _ from 'underscore';\nimport Backbone from 'backbone';\nimport Marionette from 'backbone.marionette';\n\nimport { renderView, destroyView } from './common/view';\nimport monitorViewEvents from './common/monitor-view-events';\nimport { triggerMethodOn } from './common/trigger-method';\nimport ChildViewContainer from './child-view-container';\n\nconst setDomApi = Marionette.View.setDomApi;\n\nconst ViewMixin = _.pick(Marionette.View.prototype,\n  'Dom',\n  'supportsRenderLifecycle',\n  'supportsDestroyLifecycle',\n  '_isDestroyed',\n  'isDestroyed',\n  '_isRendered',\n  'isRendered',\n  '_isAttached',\n  'isAttached',\n  'delegateEvents',\n  '_getEvents',\n  'getTriggers',\n  'delegateEntityEvents',\n  'undelegateEntityEvents',\n  'destroy',\n  '_removeElement',\n  'bindUIElements',\n  'unbindUIElements',\n  'getUI',\n  'childViewEventPrefix',\n  'triggerMethod',\n  '_buildEventProxies',\n  '_proxyChildViewEvents',\n  '_childViewEventHandler',\n  // BehaviorsMixin\n  '_initBehaviors',\n  '_getBehaviors',\n  '_getBehaviorTriggers',\n  '_getBehaviorEvents',\n  '_proxyBehaviorViewProperties',\n  '_delegateBehaviorEntityEvents',\n  '_undelegateBehaviorEntityEvents',\n  '_destroyBehaviors',\n  '_removeBehavior',\n  '_bindBehaviorUIElements',\n  '_unbindBehaviorUIElements',\n  '_triggerEventOnBehaviors',\n  // CommonMixin\n  'normalizeMethods',\n  '_setOptions',\n  'mergeOptions',\n  'getOption',\n  'bindEvents',\n  'unbindEvents',\n  // DelegateEntityEventsMixin\n  '_delegateEntityEvents',\n  '_undelegateEntityEvents',\n  // TriggersMixin\n  '_getViewTriggers',\n  // UIMixin\n  'normalizeUIKeys',\n  'normalizeUIString',\n  'normalizeUIValues',\n  '_getUIBindings',\n  '_bindUIElements',\n  '_unbindUIElements',\n  '_getUI'\n);\n\nconst isNodeAttached = Marionette.isNodeAttached;\nconst MarionetteError = Marionette.Error;\n\nconst ClassOptions = [\n  'behaviors',\n  'childView',\n  'childViewEventPrefix',\n  'childViewEvents',\n  'childViewOptions',\n  'childViewTriggers',\n  'collectionEvents',\n  'events',\n  'filter',\n  'emptyView',\n  'emptyViewOptions',\n  'modelEvents',\n  'reorderOnSort',\n  'sort',\n  'triggers',\n  'ui',\n  'viewComparator'\n];\n\n// A view that iterates over a Backbone.Collection\n// and renders an individual child view for each model.\nconst CollectionView = Backbone.View.extend({\n\n  // flag for maintaining the sorted order of the collection\n  sort: true,\n\n  // constructor\n  // option to pass `{sort: false}` to prevent the `CollectionView` from\n  // maintaining the sorted order of the collection.\n  // This will fallback onto appending childView's to the end.\n  //\n  // option to pass `{viewComparator: compFunction()}` to allow the `CollectionView`\n  // to use a custom sort order for the collection.\n  constructor(options) {\n    this.render = _.bind(this.render, this);\n\n    this._setOptions(options);\n\n    this.mergeOptions(options, ClassOptions);\n\n    monitorViewEvents(this);\n\n    this._initBehaviors();\n    this.once('render', this._initialEvents);\n    this._initChildViewStorage();\n    this._bufferedChildren = [];\n\n    const args = Array.prototype.slice.call(arguments);\n    args[0] = this.options;\n    Backbone.View.prototype.constructor.apply(this, args);\n\n    this.delegateEntityEvents();\n\n    this._triggerEventOnBehaviors('initialize', this);\n  },\n\n  // Instead of inserting elements one by one into the page, it's much more performant to insert\n  // elements into a document fragment and then insert that document fragment into the page\n  _startBuffering() {\n    this._isBuffering = true;\n  },\n\n  _endBuffering() {\n    const shouldTriggerAttach = this._isAttached && this.monitorViewEvents !== false;\n    const triggerOnChildren = shouldTriggerAttach ? this._getImmediateChildren() : [];\n\n    this._isBuffering = false;\n\n    _.each(triggerOnChildren, child => {\n      triggerMethodOn(child, 'before:attach', child);\n    });\n\n    this.attachBuffer(this, this._createBuffer());\n\n    _.each(triggerOnChildren, child => {\n      child._isAttached = true;\n      triggerMethodOn(child, 'attach', child);\n    });\n\n    this._bufferedChildren = [];\n  },\n\n  _getImmediateChildren() {\n    return _.values(this.children._views);\n  },\n\n  // Configured the initial events that the collection view binds to.\n  _initialEvents() {\n    if (this.collection) {\n      this.listenTo(this.collection, 'add', this._onCollectionAdd);\n      this.listenTo(this.collection, 'update', this._onCollectionUpdate);\n      this.listenTo(this.collection, 'reset', this.render);\n\n      if (this.sort) {\n        this.listenTo(this.collection, 'sort', this._sortViews);\n      }\n    }\n  },\n\n  // Handle a child added to the collection\n  _onCollectionAdd(child, collection, opts) {\n    // `index` is present when adding with `at` since BB 1.2; indexOf fallback for < 1.2\n    let index = opts.at !== undefined && (opts.index || collection.indexOf(child));\n\n    // When filtered or when there is no initial index, calculate index.\n    if (this.filter || index === false) {\n      index = _.indexOf(this._filteredSortedModels(index), child);\n    }\n\n    if (this._shouldAddChild(child, index)) {\n      this._destroyEmptyView();\n      this._addChild(child, index)\n    }\n  },\n\n  // Handle collection update model removals\n  _onCollectionUpdate(collection, options) {\n    const changes = options.changes;\n    this._removeChildModels(changes.removed);\n  },\n\n  // Remove the child views and destroy them.\n  // This function also updates the indices of later views\n  // in the collection in order to keep the children in sync with the collection.\n  // \"models\" is an array of models and the corresponding views\n  // will be removed and destroyed from the CollectionView\n  _removeChildModels(models) {\n    // Used to determine where to update the remaining\n    // sibling view indices after these views are removed.\n    const removedViews = this._getRemovedViews(models);\n\n    if (!removedViews.length) {\n      return;\n    }\n\n    this.children._updateLength();\n\n    // decrement the index of views after this one\n    this._updateIndices(removedViews, false);\n\n    if (this.isEmpty()) {\n      this._showEmptyView();\n    }\n  },\n\n  // Returns the views that will be used for re-indexing\n  // through CollectionView#_updateIndices.\n  _getRemovedViews(models) {\n\n    // Returning a view means something was removed.\n    return _.reduce(models, (removingViews, model) => {\n      const view = model && this.children.findByModel(model);\n\n      if (!view || view._isDestroyed) {\n        return removingViews;\n      }\n\n      this._removeChildView(view);\n\n      removingViews.push(view);\n\n      return removingViews;\n    }, []);\n  },\n\n  _removeChildView(view) {\n    this.triggerMethod('before:remove:child', this, view);\n\n    this.children._remove(view);\n    view._shouldDisableEvents = this.monitorViewEvents === false;\n    destroyView(view);\n\n    this.stopListening(view);\n    this.triggerMethod('remove:child', this, view);\n  },\n\n  // Overriding Backbone.View's `setElement` to handle\n  // if an el was previously defined. If so, the view might be\n  // attached on setElement.\n  setElement() {\n    const hasEl = !!this.el;\n\n    Backbone.View.prototype.setElement.apply(this, arguments);\n\n    if (hasEl) {\n      this._isAttached = isNodeAttached(this.el);\n    }\n\n    return this;\n  },\n\n  // Render children views. Override this method to provide your own implementation of a\n  // render function for the collection view.\n  render() {\n    if (this._isDestroyed) { return this; }\n    this.triggerMethod('before:render', this);\n    this._renderChildren();\n    this._isRendered = true;\n    this.triggerMethod('render', this);\n    return this;\n  },\n\n  // An efficient rendering used for filtering. Instead of modifying the whole DOM for the\n  // collection view, we are only adding or removing the related childrenViews.\n  setFilter(filter, {preventRender} = {}) {\n    const canBeRendered = this._isRendered && !this._isDestroyed;\n    const filterChanged = this.filter !== filter;\n    const shouldRender = canBeRendered && filterChanged && !preventRender;\n\n    if (shouldRender) {\n      const previousModels = this._filteredSortedModels();\n      this.filter = filter;\n      const models = this._filteredSortedModels();\n      this._applyModelDeltas(models, previousModels);\n    } else {\n      this.filter = filter;\n    }\n\n    return this;\n  },\n\n  // `removeFilter` is actually an alias for removing filters.\n  removeFilter(options) {\n    return this.setFilter(null, options);\n  },\n\n  // Calculate and apply difference by cid between `models` and `previousModels`.\n  _applyModelDeltas(models, previousModels) {\n    const currentIds = {};\n    _.each(models, (model, index) => {\n      const addedChildNotExists = !this.children.findByModel(model);\n      if (addedChildNotExists) {\n        this._onCollectionAdd(model, this.collection, {at: index});\n      }\n      currentIds[model.cid] = true;\n    });\n\n    const removeModels = _.filter(previousModels, (prevModel) => {\n      return !currentIds[prevModel.cid] && this.children.findByModel(prevModel);\n    });\n\n    this._removeChildModels(removeModels);\n  },\n\n  // Reorder DOM after sorting. When your element's rendering do not use their index,\n  // you can pass reorderOnSort: true to only reorder the DOM after a sort instead of\n  // rendering all the collectionView.\n  reorder() {\n    const children = this.children;\n    const models = this._filteredSortedModels();\n\n    if (!models.length && this._showingEmptyView) { return this; }\n\n    const anyModelsAdded = _.some(models, function(model) {\n      return !children.findByModel(model);\n    });\n\n    // If there are any new models added due to filtering we need to add child views,\n    // so render as normal.\n    if (anyModelsAdded) {\n      this.render();\n    } else {\n\n      const filteredOutModels = [];\n\n      // Get the DOM nodes in the same order as the models and\n      // find the model that were children before but aren't in this new order.\n      const elsToReorder = _.reduce(this.children._views, function(viewEls, view) {\n        const index = _.indexOf(models, view.model);\n\n        if (index === -1) {\n          filteredOutModels.push(view.model);\n          return viewEls;\n        }\n\n        view._index = index;\n\n        viewEls[index] = view.el;\n\n        return viewEls;\n      }, new Array(models.length));\n\n      this.triggerMethod('before:reorder', this);\n\n      const elBuffer = this.Dom.createBuffer();\n\n      _.each(elsToReorder, (el) => {\n        this.Dom.appendContents(elBuffer, el);\n      });\n\n      // Since append moves elements that are already in the DOM, appending the elements\n      // will effectively reorder them.\n      this._appendReorderedChildren(elBuffer);\n\n      // remove any views that have been filtered out\n      this._removeChildModels(filteredOutModels);\n\n      this.triggerMethod('reorder', this);\n    }\n    return this;\n  },\n\n  // Render view after sorting. Override this method to change how the view renders\n  // after a `sort` on the collection.\n  resortView() {\n    if (this.reorderOnSort) {\n      this.reorder();\n    } else {\n      this._renderChildren();\n    }\n    return this;\n  },\n\n  // Internal method. This checks for any changes in the order of the collection.\n  // If the index of any view doesn't match, it will render.\n  _sortViews() {\n    const models = this._filteredSortedModels();\n\n    // check for any changes in sort order of views\n    const orderChanged = _.find(models, (item, index) => {\n      const view = this.children.findByModel(item);\n      return !view || view._index !== index;\n    });\n\n    if (orderChanged) {\n      this.resortView();\n    }\n  },\n\n  // Internal reference to what index a `emptyView` is.\n  _emptyViewIndex: -1,\n\n  // Internal method. Separated so that CompositeView can append to the childViewContainer\n  // if necessary\n  _appendReorderedChildren(children) {\n    this.Dom.appendContents(this.el, children, {_$el: this.$el});\n  },\n\n  // Internal method. Separated so that CompositeView can have more control over events\n  // being triggered, around the rendering process\n  _renderChildren() {\n    if (this._isRendered) {\n      this._destroyEmptyView();\n      this._destroyChildren();\n    }\n\n    const models = this._filteredSortedModels();\n    if (this.isEmpty({processedModels: models})) {\n      this._showEmptyView();\n    } else {\n      this.triggerMethod('before:render:children', this);\n      this._startBuffering();\n      this._showCollection(models);\n      this._endBuffering();\n      this.triggerMethod('render:children', this);\n    }\n  },\n\n  _createView(model, index) {\n    const ChildView = this._getChildView(model);\n    const childViewOptions = this._getChildViewOptions(model, index);\n    const view = this.buildChildView(model, ChildView, childViewOptions);\n    return view;\n  },\n\n  _setupChildView(view, index) {\n    monitorViewEvents(view);\n\n    // set up the child view event forwarding\n    this._proxyChildViewEvents(view);\n\n    if (this.sort) {\n      view._index = index;\n    }\n  },\n\n  // Internal method to loop through collection and show each child view.\n  _showCollection(models) {\n    _.each(models, _.bind(this._addChild, this));\n    this.children._updateLength();\n  },\n\n  // Allow the collection to be sorted by a custom view comparator\n  _filteredSortedModels(addedAt) {\n    if (!this.collection || !this.collection.length) { return []; }\n\n    const viewComparator = this.getViewComparator();\n    let models = this.collection.models;\n    addedAt = Math.min(Math.max(addedAt, 0), models.length - 1);\n\n    if (viewComparator) {\n      let addedModel;\n      // Preserve `at` location, even for a sorted view\n      if (addedAt) {\n        addedModel = models[addedAt];\n        models = models.slice(0, addedAt).concat(models.slice(addedAt + 1));\n      }\n      models = this._sortModelsBy(models, viewComparator);\n      if (addedModel) {\n        models.splice(addedAt, 0, addedModel);\n      }\n    }\n\n    // Filter after sorting in case the filter uses the index\n    models = this._filterModels(models);\n\n    return models;\n  },\n\n  getViewComparator() {\n    return this.viewComparator;\n  },\n\n  // Filter an array of models, if a filter exists\n  _filterModels(models) {\n    if (this.filter) {\n      models = _.filter(models, (model, index) => {\n        return this._shouldAddChild(model, index);\n      });\n    }\n    return models;\n  },\n\n  _sortModelsBy(models, comparator) {\n    if (typeof comparator === 'string') {\n      return _.sortBy(models, (model) => {\n        return model.get(comparator);\n      });\n    } else if (comparator.length === 1) {\n      return _.sortBy(models, _.bind(comparator, this));\n    } else {\n      return _.clone(models).sort(_.bind(comparator, this));\n    }\n  },\n\n  // Internal method to show an empty view in place of a collection of child views,\n  // when the collection is empty\n  _showEmptyView() {\n    const EmptyView = this._getEmptyView();\n\n    if (EmptyView && !this._showingEmptyView) {\n      this._showingEmptyView = true;\n\n      const model = new Backbone.Model();\n      let emptyViewOptions =\n        this.emptyViewOptions || this.childViewOptions;\n      if (_.isFunction(emptyViewOptions)) {\n        emptyViewOptions = emptyViewOptions.call(this, model, this._emptyViewIndex);\n      }\n\n      const view = this.buildChildView(model, EmptyView, emptyViewOptions);\n\n      this.triggerMethod('before:render:empty', this, view);\n      this.addChildView(view, 0);\n      this.triggerMethod('render:empty', this, view);\n    }\n  },\n\n  // Internal method to destroy an existing emptyView instance if one exists. Called when\n  // a collection view has been rendered empty, and then a child is added to the collection.\n  _destroyEmptyView() {\n    if (this._showingEmptyView) {\n      this.triggerMethod('before:remove:empty', this);\n\n      this._destroyChildren();\n      delete this._showingEmptyView;\n\n      this.triggerMethod('remove:empty', this);\n    }\n  },\n\n  // Retrieve the empty view class\n  _getEmptyView() {\n    const emptyView = this.emptyView;\n\n    if (!emptyView) { return; }\n\n    return this._getView(emptyView);\n  },\n\n  // Retrieve the `childView` class\n  // The `childView` property can be either a view class or a function that\n  // returns a view class. If it is a function, it will receive the model that\n  // will be passed to the view instance (created from the returned view class)\n  _getChildView(child) {\n    let childView = this.childView;\n\n    if (!childView) {\n      throw new MarionetteError({\n        name: 'NoChildViewError',\n        message: 'A \"childView\" must be specified'\n      });\n    }\n\n    childView = this._getView(childView, child);\n\n    if (!childView) {\n      throw new MarionetteError({\n        name: 'InvalidChildViewError',\n        message: '\"childView\" must be a view class or a function that returns a view class'\n      });\n    }\n\n    return childView;\n  },\n\n  // First check if the `view` is a view class (the common case)\n  // Then check if it's a function (which we assume that returns a view class)\n  _getView(view, child) {\n    if (view.prototype instanceof Backbone.View || view === Backbone.View) {\n      return view;\n    } else if (_.isFunction(view)) {\n      return view.call(this, child);\n    }\n  },\n\n  // Internal method for building and adding a child view\n  _addChild(child, index) {\n    const view = this._createView(child, index);\n    this.addChildView(view, index);\n\n    return view;\n  },\n\n  _getChildViewOptions(child, index) {\n    if (_.isFunction(this.childViewOptions)) {\n      return this.childViewOptions(child, index);\n    }\n\n    return this.childViewOptions;\n  },\n\n  // Render the child's view and add it to the HTML for the collection view at a given index.\n  // This will also update the indices of later views in the collection in order to keep the\n  // children in sync with the collection.\n  addChildView(view, index) {\n    this.triggerMethod('before:add:child', this, view);\n    this._setupChildView(view, index);\n\n    // Store the child view itself so we can properly remove and/or destroy it later\n    if (this._isBuffering) {\n      // Add to children, but don't update children's length.\n      this.children._add(view);\n    } else {\n      // increment indices of views after this one\n      this._updateIndices(view, true);\n      this.children.add(view);\n    }\n\n    renderView(view);\n\n    this._attachView(view, index);\n\n    this.triggerMethod('add:child', this, view);\n\n    return view;\n  },\n\n  // Internal method. This decrements or increments the indices of views after the added/removed\n  // view to keep in sync with the collection.\n  _updateIndices(views, increment) {\n    if (!this.sort) {\n      return;\n    }\n\n    if (!increment) {\n      _.each(_.sortBy(this.children._views, '_index'), (view, index) => {\n        view._index = index;\n      });\n\n      return;\n    }\n\n    const view = _.isArray(views) ? _.max(views, '_index') : views;\n\n    if (_.isObject(view)) {\n      // update the indexes of views after this one\n      _.each(this.children._views, (laterView) => {\n        if (laterView._index >= view._index) {\n          laterView._index += 1;\n        }\n      });\n    }\n  },\n\n  _attachView(view, index) {\n    // Only trigger attach if already attached and not buffering,\n    // otherwise _endBuffering() or Region#show() handles this.\n    const shouldTriggerAttach = !view._isAttached && !this._isBuffering && this._isAttached && this.monitorViewEvents !== false;\n\n    if (shouldTriggerAttach) {\n      triggerMethodOn(view, 'before:attach', view);\n    }\n\n    this.attachHtml(this, view, index);\n\n    if (shouldTriggerAttach) {\n      view._isAttached = true;\n      triggerMethodOn(view, 'attach', view);\n    }\n  },\n\n  // Build a `childView` for a model in the collection.\n  buildChildView(child, ChildViewClass, childViewOptions) {\n    const options = _.extend({model: child}, childViewOptions);\n    return new ChildViewClass(options);\n  },\n\n  // Remove the child view and destroy it. This function also updates the indices of later views\n  // in the collection in order to keep the children in sync with the collection.\n  removeChildView(view) {\n    if (!view || view._isDestroyed) {\n      return view;\n    }\n\n    this._removeChildView(view);\n    this.children._updateLength();\n    // decrement the index of views after this one\n    this._updateIndices(view, false);\n    return view;\n  },\n\n  // check if the collection is empty or optionally whether an array of pre-processed models is empty\n  isEmpty(options) {\n    let models;\n    if (_.result(options, 'processedModels')) {\n      models = options.processedModels;\n    } else {\n      models = this.collection ? this.collection.models : [];\n      models = this._filterModels(models);\n    }\n    return models.length === 0;\n  },\n\n  // You might need to override this if you've overridden attachHtml\n  attachBuffer(collectionView, buffer) {\n    this.Dom.appendContents(collectionView.el, buffer, {_$el: collectionView.$el});\n  },\n\n  // Create a fragment buffer from the currently buffered children\n  _createBuffer() {\n    const elBuffer = this.Dom.createBuffer();\n    _.each(this._bufferedChildren, (b) => {\n      this.Dom.appendContents(elBuffer, b.el, {_$contents: b.$el});\n    });\n    return elBuffer;\n  },\n\n  // Append the HTML to the collection's `el`. Override this method to do something other\n  // than `.append`.\n  attachHtml(collectionView, childView, index) {\n    if (collectionView._isBuffering) {\n      // buffering happens on reset events and initial renders\n      // in order to reduce the number of inserts into the\n      // document, which are expensive.\n      collectionView._bufferedChildren.splice(index, 0, childView);\n    } else {\n      // If we've already rendered the main collection, append\n      // the new child into the correct order if we need to. Otherwise\n      // append to the end.\n      if (!collectionView._insertBefore(childView, index)) {\n        collectionView._insertAfter(childView);\n      }\n    }\n  },\n\n  // Internal method. Check whether we need to insert the view into the correct position.\n  _insertBefore(childView, index) {\n    let currentView;\n    const findPosition = this.sort && (index < this.children.length - 1);\n    if (findPosition) {\n      // Find the view after this one\n      currentView = _.find(this.children._views, (view) => {\n        return view._index === index + 1;\n      });\n    }\n\n    if (currentView) {\n      this.beforeEl(currentView.el, childView.el);\n      return true;\n    }\n\n    return false;\n  },\n\n  // Override to handle DOM inserting differently\n  beforeEl(el, siblings) {\n    this.$(el).before(siblings);\n  },\n\n  // Internal method. Append a view to the end of the $el\n  _insertAfter(childView) {\n    this.Dom.appendContents(this.el, childView.el, {_$el: this.$el, _$contents: childView.$el});\n  },\n\n  // Internal method to set up the `children` object for storing all of the child views\n  _initChildViewStorage() {\n    this.children = new ChildViewContainer();\n  },\n\n  // called by ViewMixin destroy\n  _removeChildren() {\n    this._destroyChildren();\n  },\n\n  // Destroy the child views that this collection view is holding on to, if any\n  _destroyChildren(options) {\n    if (!this.children.length) {\n      return;\n    }\n\n    this.triggerMethod('before:destroy:children', this);\n    _.each(this.children._views, _.bind(this._removeChildView, this));\n    this.children._updateLength();\n    this.triggerMethod('destroy:children', this);\n  },\n\n  // Return true if the given child should be shown. Return false otherwise.\n  // The filter will be passed (child, index, collection), where\n  //  'child' is the given model\n  //  'index' is the index of that model in the collection\n  //  'collection' is the collection referenced by this CollectionView\n  _shouldAddChild(child, index) {\n    const filter = this.filter;\n    return !_.isFunction(filter) || filter.call(this, child, index, this.collection);\n  }\n}, {\n  setDomApi\n});\n\n_.extend(CollectionView.prototype, ViewMixin);\n\nexport default CollectionView;\n","// Composite View\n// --------------\n\nimport _ from 'underscore';\nimport Marionette from 'backbone.marionette';\nimport CollectionView from './collection-view';\n\nconst MarionetteError = Marionette.Error;\nconst View = Marionette.View;\n\nconst ClassOptions = [\n  'childViewContainer',\n  'template',\n  'templateContext'\n];\n\n// Used for rendering a branch-leaf, hierarchical structure.\n// Extends directly from CollectionView\n// @deprecated\nconst CompositeView = CollectionView.extend({\n\n  // Setting up the inheritance chain which allows changes to\n  // Marionette.CollectionView.prototype.constructor which allows overriding\n  // option to pass '{sort: false}' to prevent the CompositeView from\n  // maintaining the sorted order of the collection.\n  // This will fallback onto appending childView's to the end.\n  constructor(options) {\n    this.mergeOptions(options, ClassOptions);\n\n    CollectionView.prototype.constructor.apply(this, arguments);\n  },\n\n  // Configured the initial events that the composite view\n  // binds to. Override this method to prevent the initial\n  // events, or to add your own initial events.\n  _initialEvents() {\n\n    // Bind only after composite view is rendered to avoid adding child views\n    // to nonexistent childViewContainer\n\n    if (this.collection) {\n      this.listenTo(this.collection, 'add', this._onCollectionAdd);\n      this.listenTo(this.collection, 'update', this._onCollectionUpdate);\n      this.listenTo(this.collection, 'reset', this.renderChildren);\n\n      if (this.sort) {\n        this.listenTo(this.collection, 'sort', this._sortViews);\n      }\n    }\n  },\n\n  // Retrieve the `childView` to be used when rendering each of\n  // the items in the collection. The default is to return\n  // `this.childView` or Marionette.CompositeView if no `childView`\n  // has been defined. As happens in CollectionView, `childView` can\n  // be a function (which should return a view class).\n  _getChildView(child) {\n    let childView = this.childView;\n\n    // for CompositeView, if `childView` is not specified, we'll get the same\n    // composite view class rendered for each child in the collection\n    // then check if the `childView` is a view class (the common case)\n    // finally check if it's a function (which we assume that returns a view class)\n    if (!childView) {\n      return this.constructor;\n    }\n\n    childView = this._getView(childView, child);\n\n    if (!childView) {\n      throw new MarionetteError({\n        name: 'InvalidChildViewError',\n        message: '\"childView\" must be a view class or a function that returns a view class'\n      });\n    }\n\n    return childView;\n  },\n\n  // Return the serialized model\n  serializeData() {\n    return this.serializeModel();\n  },\n\n  // Renders the model and the collection.\n  render() {\n    if (this._isDestroyed) { return this; }\n    this._isRendering = true;\n    this.resetChildViewContainer();\n\n    this.triggerMethod('before:render', this);\n\n    this._renderTemplate();\n    this.bindUIElements();\n    this.renderChildren();\n\n    this._isRendering = false;\n    this._isRendered = true;\n    this.triggerMethod('render', this);\n    return this;\n  },\n\n  renderChildren() {\n    if (this._isRendered || this._isRendering) {\n      CollectionView.prototype._renderChildren.call(this);\n    }\n  },\n\n  // You might need to override this if you've overridden attachHtml\n  attachBuffer(compositeView, buffer) {\n    const $container = this.getChildViewContainer(compositeView);\n    this.Dom.appendContents($container[0], buffer, {_$el: $container});\n  },\n\n  // Internal method. Append a view to the end of the $el.\n  // Overidden from CollectionView to ensure view is appended to\n  // childViewContainer\n  _insertAfter(childView) {\n    const $container = this.getChildViewContainer(this, childView);\n    this.Dom.appendContents($container[0], childView.el, {_$el: $container, _$contents: childView.$el});\n  },\n\n  // Internal method. Append reordered childView'.\n  // Overidden from CollectionView to ensure reordered views\n  // are appended to childViewContainer\n  _appendReorderedChildren(children) {\n    const $container = this.getChildViewContainer(this);\n    this.Dom.appendContents($container[0], children, {_$el: $container});\n  },\n\n  // Internal method to ensure an `$childViewContainer` exists, for the\n  // `attachHtml` method to use.\n  getChildViewContainer(containerView, childView) {\n    if (!!containerView.$childViewContainer) {\n      return containerView.$childViewContainer;\n    }\n\n    let container;\n    const childViewContainer = containerView.childViewContainer;\n    if (childViewContainer) {\n\n      const selector = _.result(containerView, 'childViewContainer');\n\n      if (selector.charAt(0) === '@' && containerView.ui) {\n        container = containerView.ui[selector.substr(4)];\n      } else {\n        container = this.$(selector);\n      }\n\n      if (container.length <= 0) {\n        throw new MarionetteError({\n          name: 'ChildViewContainerMissingError',\n          message: `The specified \"childViewContainer\" was not found: ${containerView.childViewContainer}`\n        });\n      }\n\n    } else {\n      container = containerView.$el;\n    }\n\n    containerView.$childViewContainer = container;\n    return container;\n  },\n\n  // Internal method to reset the `$childViewContainer` on render\n  resetChildViewContainer() {\n    if (this.$childViewContainer) {\n      this.$childViewContainer = undefined;\n    }\n  }\n});\n\n// To prevent duplication but allow the best View organization\n// Certain View methods are mixed directly into the deprecated CompositeView\nconst MixinFromView = _.pick(View.prototype, 'serializeModel', 'getTemplate', '_renderTemplate', '_renderHtml', 'mixinTemplateContext', 'attachElContent');\n_.extend(CompositeView.prototype, MixinFromView);\n\nexport default CompositeView;\n","import Marionette from 'backbone.marionette';\nimport OldCollectionView from './collection-view';\nimport OldCompositeView from './composite-view';\n\nMarionette.OldCollectionView = OldCollectionView;\nMarionette.OldCompositeView = OldCompositeView;\n\nexport { OldCollectionView, OldCompositeView }\n"]}